C51 COMPILER V9.59.0.0   MAIN                                                              06/15/2024 01:13:02 PAGE 1   


C51 COMPILER V9.59.0.0, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN ..\..\hex\MAIN.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE MAIN.C LARGE OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND TABS(2) OBJECT(
                    -..\..\hex\MAIN.obj)

line level    source

   1          #include "lpcreg.h"
   2          #include "main.h"
   3          #include "mfrc522.h"
   4          #include "12864.h"
   5          #include <nokia5110.h>
   6          #include <stdio.h>
   7          #include <string.h>
   8          
   9          #define uchar unsigned char  // 定义无符号字符类型
  10          #define MAX_LEN 16  // 数据最大长度
  11          
  12          uchar Char;  // 定义字符变量Char
  13          uchar flag;  // 定义标志位变量flag
  14          uchar received_data[MAX_LEN];  // 存储接收到的数据
  15          uchar data_index = 0;  // 数据索引
  16          //前五位cqust   中间10位学生卡号
  17          uchar response_array[16] = {0x63, 0x71, 0x75, 0x73, 0x74, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
             -0x00, 0x00, 0x23};  // 响应数组
  18          
  19          //前两位 ok  中间十位学生卡号
  20          uchar write_ok[16] = {0x6F, 0x6B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
             -0x00, 0x23};  // 成功响应数组
  21          
  22          //前六位 cqust 中间8位 标签卡号
  23          uchar card_id[16] = {0x63, 0x61, 0x72, 0x64, 0x69, 0x64, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0
             -x00, 0x23};  // 卡片id响应数组
  24          
  25          
  26          
  27          
  28          unsigned char g_ucTempbuf[16];
  29          unsigned char code DefaultKey[6] = { 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF };
  30          uchar i;
  31          
  32          
  33          
  34          
  35          //是否读到卡标志 0未读 1读卡
  36          uchar is_card_read = 0;
  37          //运行模式标志位 0读卡 1写卡
  38          uchar run_mode = 0;
  39          //是否接收到数据
  40          uchar is_read_data = 0;
  41          
  42          void delay1(unsigned int z) {
  43   1          unsigned int x, y;
  44   1          for (x = z; x > 0; x--)
  45   1              for (y = 110; y > 0; y--);
  46   1      }
  47          
  48          // UART发送一个字节函数
  49          void UART_sendbyte(uchar Byte) {
  50   1          SBUF = Byte; 
  51   1          while (TI == 0); 
C51 COMPILER V9.59.0.0   MAIN                                                              06/15/2024 01:13:02 PAGE 2   

  52   1          TI = 0;  
  53   1      }
  54          
  55          //转asc
  56          uchar nibble_to_ascii(uchar nibble) {
  57   1          if (nibble < 10) {
  58   2              return '0' + nibble;
  59   2          } else {
  60   2              return 'A' + (nibble - 10);
  61   2          }
  62   1      }
  63          
  64          
  65          // 主函数
  66          void main() {
  67   1          unsigned char status;
  68   1          unsigned int temp;
  69   1      
  70   1          LCD_init();
  71   1          LCD_clear();
  72   1      
  73   1          InitializeSystem();
  74   1          PcdReset();
  75   1          PcdAntennaOff();
  76   1          PcdAntennaOn();
  77   1      
  78   1          while (1) {
  79   2      
  80   2        status = PcdRequest(PICC_REQALL, g_ucTempbuf);//寻卡
  81   2          if (status != MI_OK)
  82   2          {
  83   3            continue;
  84   3          }
  85   2      
  86   2      
  87   2      
  88   2          
  89   2          status = PcdAnticoll(g_ucTempbuf);//防冲撞
  90   2          if (status != MI_OK)
  91   2          {
  92   3            continue;
  93   3          }
  94   2      
  95   2          
  96   2      
  97   2          for (i = 0; i < 4; i++)
  98   2          {
  99   3              card_id[6 + 2*i] = (g_ucTempbuf[i] >> 4) & 0x0F;  // 高4位
 100   3              card_id[7 + 2*i] = g_ucTempbuf[i] & 0x0F;         // 低4位
 101   3      
 102   3          }
 103   2          
 104   2          for (i = 0; i < 4; i++) {
 105   3              uchar high_nibble = (g_ucTempbuf[i] >> 4) & 0x0F;  // 高4位
 106   3              uchar low_nibble = g_ucTempbuf[i] & 0x0F;          // 低4位
 107   3              
 108   3              card_id[6 + 2*i] = nibble_to_ascii(high_nibble);   // 高4位转换为 ASCII
 109   3              card_id[7 + 2*i] = nibble_to_ascii(low_nibble);    // 低4位转换为 ASCII
 110   3          }
 111   2          
 112   2          //卡片
 113   2          for (i = 0; i < 16; i++) {
C51 COMPILER V9.59.0.0   MAIN                                                              06/15/2024 01:13:02 PAGE 3   

 114   3                       UART_sendbyte(card_id[i]) ;
 115   3                  }
 116   2          
 117   2          status = PcdSelect(g_ucTempbuf);//选定卡片
 118   2          if (status != MI_OK)
 119   2          {
 120   3            continue;
 121   3          }
 122   2      
 123   2          status = PcdAuthState(PICC_AUTHENT1A, 1, DefaultKey, g_ucTempbuf);//验证卡片密码
 124   2          if (status != MI_OK)
 125   2          {
 126   3            continue;
 127   3          }
 128   2            
 129   2          
 130   2              
 131   2                  #写卡
*** WARNING C314 IN LINE 131 OF MAIN.C: bad #directive syntax
 132   2                  if (received_data[0] == 'w') { 
 133   3                      for (i = 0; i < 10; i++) {
 134   4                          response_array[5 + i] = received_data[1 + i];
 135   4                          write_ok[2+i]=received_data[1 + i];
 136   4                      }
 137   3                      status = PcdWrite(2, response_array);  // 写数据
 138   3                      if (status != MI_OK) {
 139   4                          continue;
 140   4                      }
 141   3                      //返回成功响应
 142   3                      for (i = 0; i < 16; i++) {
 143   4                         UART_sendbyte(write_ok[i]) ;
 144   4                      }
 145   3                      
 146   3                  } 
 147   2                  #读取卡片数据
*** WARNING C314 IN LINE 147 OF MAIN.C: bad #directive syntax
 148   2                  else if (received_data[0] == 'r') {
 149   3                      status = PcdRead(2, g_ucTempbuf);
 150   3                      if (status != MI_OK) {
 151   4        
 152   4                          continue;
 153   4                      }
 154   3                        for (i = 0; i < 16; i++) {
 155   4                         UART_sendbyte(g_ucTempbuf[i]) ;
 156   4                      }
 157   3                  
 158   3                  }
 159   2              
 160   2              
 161   2      
 162   2              /*LED_GREEN = 0;
 163   2              delay1(100);
 164   2              LED_GREEN = 1;
 165   2              delay1(100);
 166   2              LED_GREEN = 0;
 167   2              delay1(200);
 168   2              LED_GREEN = 1;*/
 169   2                  
 170   2                  
 171   2                  
 172   2              PcdHalt();
 173   2          }
C51 COMPILER V9.59.0.0   MAIN                                                              06/15/2024 01:13:02 PAGE 4   

 174   1      }
*** WARNING C280 IN LINE 68 OF MAIN.C: 'temp': unreferenced local variable
 175          
 176          // 系统初始化
 177          void InitializeSystem() {
 178   1              // I/O 端口配置
 179   1          P0M1 = 0x0; P0M2 = 0x0;
 180   1          P1M1 = 0x0; P1M2 = 0x0;
 181   1          P3M1 = 0x0; P3M2 = 0xFF;
 182   1          P0 = 0xFF; P1 = 0xFF; P3 = 0xFF; P2 = 0xFF;
 183   1      
 184   1          // 串口配置
 185   1          SCON = 0x50; // 串行通信模式1，8位数据，允许接收
 186   1      
 187   1          // 定时器配置
 188   1          TMOD = 0x20; // T1为方式2（8位自动重装）
 189   1      
 190   1          // 设置定时器初值
 191   1          TH1 = 0xFA;  // 设置波特率为4800bps
 192   1          TL1 = 0xFA;
 193   1      
 194   1          // 启动定时器1
 195   1          TR1 = 1;    // 启动定时器1
 196   1      
 197   1          // 中断配置
 198   1          ES = 1;      // 允许串行中断
 199   1          EA = 1;      // 开启总中断
 200   1      
 201   1          // 设置标志
 202   1          TI = 1;
 203   1        
 204   1         
 205   1            /*P0M1 = 0x0; P0M2 = 0x0;
 206   1        P1M1 = 0x0; P1M2 = 0x0;
 207   1        P3M1 = 0x0; P3M2 = 0xFF;
 208   1        P0 = 0xFF; P1 = 0xFF; P3 = 0xFF; P2 = 0xFF;
 209   1      
 210   1        TMOD = 0x21;       //设T0为方式1，GATE=1；
 211   1        SCON = 0x50;
 212   1        TH1 = 0xFA;          //波特率为4800bps
 213   1        TL1 = 0xFA;
 214   1        TH0 = 0;
 215   1        TL0 = 0;
 216   1        TR0 = 1;
 217   1        ET0 = 1;             //允许T0中断
 218   1        TR1 = 1;         //开启定时器
 219   1        TI = 1;
 220   1        EA = 1;         //开启总中断
 221   1      
 222   1        ES = 1;
 223   1        RI = 1;
 224   1      
 225   1        */
 226   1      }
 227          
 228          // UART接收中断服务函数
 229          void UART_R() interrupt 4 {
 230   1          if (RI == 1) {  // 如果接收到数据
 231   2              Char = SBUF;  // 读取接收到的数据到Char变量
 232   2      
 233   2              RI = 0;  // 清除接收标志位
 234   2              if (Char == '#') {  // 检测到结束符
C51 COMPILER V9.59.0.0   MAIN                                                              06/15/2024 01:13:02 PAGE 5   

 235   3                  is_read_data = 1;
 236   3      
 237   3                  data_index = 0;  
 238   3              } else {
 239   3                  if (data_index <= MAX_LEN - 1) {  // 防止数组越界
 240   4                      received_data[data_index++] = Char;
 241   4                  }
 242   3              }
 243   2          }
 244   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    730    ----
   CONSTANT SIZE    =      6    ----
   XDATA SIZE       =     87       4
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  3 WARNING(S),  0 ERROR(S)
