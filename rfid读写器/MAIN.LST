C51 COMPILER V9.59.0.0   MAIN                                                              06/19/2024 00:49:16 PAGE 1   


C51 COMPILER V9.59.0.0, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN ..\..\hex\MAIN.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE MAIN.C LARGE OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND TABS(2) OBJECT(
                    -..\..\hex\MAIN.obj)

line level    source

   1          #include "lpcreg.h"
   2          #include "main.h"
   3          #include "mfrc522.h"
   4          #include "12864.h"
   5          #include <nokia5110.h>
   6          #include <stdio.h>
   7          #include <string.h>
   8          
   9          #define uchar unsigned char  // 定义无符号字符类型
  10          #define MAX_LEN 16  // 数据最大长度
  11          #define FIRST_ROW 0
  12          #define SECOND_ROW 2
  13          #define THIRD_ROW 4
  14          
  15          uchar Char;  // 定义字符变量Char
  16          uchar flag;  // 定义标志位变量flag
  17          uchar received_data[MAX_LEN];  // 存储接收到的数据
  18          uchar data_index = 0;  // 数据索引
  19          //前五位cqust   中间10位学生卡号
  20          uchar response_array[16] = {0x63, 0x71, 0x75, 0x73, 0x74, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
             -0x00, 0x00, 0x23};  // 响应数组
  21          
  22          //前两位 ok  中间十位学生卡号
  23          uchar write_ok[16] = {0x6F, 0x6B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
             -0x00, 0x23};  // 成功响应数组
  24          
  25          //前六位 cardid 中间8位 标签卡号
  26          uchar card_id[16] = {0x63, 0x61, 0x72, 0x64, 0x69, 0x64, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0
             -x00, 0x23};  // 卡片id响应数组
  27          
  28          
  29          
  30          
  31          unsigned char g_ucTempbuf[16];
  32          unsigned char code DefaultKey[6] = { 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF };
  33          
  34          uchar i;
  35          
  36          
  37          
  38          
  39          //是否读到卡标志 0未读 1读卡
  40          uchar is_card_read = 0;
  41          //运行模式标志位 0读卡 1写卡
  42          uchar run_mode = 0;
  43          //是否接收到数据
  44          uchar is_read_data = 0;
  45          
  46          
  47          
  48          void delay1(unsigned int z) {
  49   1          unsigned int x, y;
  50   1          for (x = z; x > 0; x--)
  51   1              for (y = 110; y > 0; y--);
C51 COMPILER V9.59.0.0   MAIN                                                              06/19/2024 00:49:16 PAGE 2   

  52   1      }
  53          
  54          // UART发送一个字节函数
  55          void UART_sendbyte(uchar Byte) {
  56   1          SBUF = Byte; 
  57   1          while (TI == 0); 
  58   1          TI = 0;  
  59   1      }
  60          
  61          //转asc
  62          uchar nibble_to_ascii(uchar nibble) {
  63   1          if (nibble < 10) {
  64   2              return '0' + nibble;
  65   2          } else {
  66   2              return 'A' + (nibble - 10);
  67   2          }
  68   1      }
  69          
  70          
  71          void clear_row(uchar row){
  72   1        for(i=0;i<15;i++){
  73   2          LCD_write_shu(i,row,37);
  74   2          
  75   2        }
  76   1      }
  77          
  78          void write_title(uchar row){
  79   1          //cqust考勤系统
  80   1          LCD_write_shu(0,row,12);
  81   1          LCD_write_shu(1,row,26);
  82   1          LCD_write_shu(2,row,30);
  83   1          LCD_write_shu(3,row,28);
  84   1          LCD_write_shu(4,row,29);
  85   1        
  86   1          LCD_write_shu(5,row,37);
  87   1        
  88   1          LCD_write_hanzi(6,row,0);
  89   1          LCD_write_hanzi(8,row,1);
  90   1          LCD_write_hanzi(10,row,2);
  91   1          LCD_write_hanzi(12,row,3);
  92   1        
  93   1      }
  94          
  95          void write_sno(uchar row){
  96   1            //学号
  97   1            LCD_write_hanzi(0,row,8);
  98   1            LCD_write_hanzi(2,row,9);
  99   1            for (i = 0; i < 10; i++) {
 100   2                  LCD_write_shu(i+4,row,received_data[1 + i]-'0');            
 101   2              }
 102   1            
 103   1      }
 104          
 105          void write_bang_ding_chen_gong(uchar row){
 106   1          
 107   1            LCD_write_hanzi(2,row,10);
 108   1            LCD_write_hanzi(4,row,11);
 109   1            LCD_write_hanzi(6,row,6);
 110   1            LCD_write_hanzi(8,row,7);
 111   1      
 112   1      }
 113          
C51 COMPILER V9.59.0.0   MAIN                                                              06/19/2024 00:49:16 PAGE 3   

 114          void display_cardnum(uchar row)
 115          {
 116   1        unsigned char first,second; 
 117   1        //卡号:
 118   1        LCD_write_hanzi(0,row,5);
 119   1          LCD_write_hanzi(2,row,9); 
 120   1         LCD_write_shu(4,row,36); 
 121   1        first=(g_ucTempbuf[0]&0xf0)>>4;
 122   1        LCD_write_shu(5,row,first);//写数字
 123   1          second=g_ucTempbuf[0]&0x0f;
 124   1        LCD_write_shu(6,row,second);//写数字
 125   1      
 126   1          first=(g_ucTempbuf[1]&0xf0)>>4;
 127   1        LCD_write_shu(7,row,first);//写数字
 128   1          second=g_ucTempbuf[1]&0x0f;
 129   1        LCD_write_shu(8,row,second);//写数字
 130   1          
 131   1          first=(g_ucTempbuf[2]&0xf0)>>4;
 132   1        LCD_write_shu(9,row,first);//写数字
 133   1          second=g_ucTempbuf[2]&0x0f;
 134   1        LCD_write_shu(10,row,second);//写数字
 135   1      
 136   1          first=(g_ucTempbuf[3]&0xf0)>>4;
 137   1        LCD_write_shu(11,row,first);//写数字
 138   1          second=g_ucTempbuf[3]&0x0f;
 139   1        LCD_write_shu(12,row,second);//写数字
 140   1         LCD_write_shu(13,row,37);
 141   1      }
 142          
 143          // 主函数
 144          void main() {
 145   1          unsigned char status;
 146   1          unsigned int temp;
 147   1      
 148   1          LCD_init();
 149   1          LCD_clear();
 150   1          write_title(FIRST_ROW);
 151   1          InitializeSystem();
 152   1          PcdReset();
 153   1          PcdAntennaOff();
 154   1          PcdAntennaOn();
 155   1        
 156   1      while (1) {
 157   2      
 158   2          status = PcdRequest(PICC_REQALL, g_ucTempbuf); // 寻卡
 159   2          if (status != MI_OK)
 160   2          {
 161   3            
 162   3             write_title(FIRST_ROW);
 163   3              clear_row(SECOND_ROW );
 164   3              clear_row(THIRD_ROW );
 165   3              continue;
 166   3          }
 167   2      
 168   2          status = PcdAnticoll(g_ucTempbuf); // 防冲撞
 169   2          if (status != MI_OK)
 170   2          {
 171   3          
 172   3              continue;
 173   3          }
 174   2      
 175   2          // 转换卡片发送
C51 COMPILER V9.59.0.0   MAIN                                                              06/19/2024 00:49:16 PAGE 4   

 176   2          for (i = 0; i < 4; i++)
 177   2          {
 178   3              uchar high_nibble = (g_ucTempbuf[i] >> 4) & 0x0F;  // 高4位
 179   3              uchar low_nibble = g_ucTempbuf[i] & 0x0F;          // 低4位
 180   3              
 181   3              card_id[6 + 2*i] = nibble_to_ascii(high_nibble);   // 高4位转换为 ASCII
 182   3              card_id[7 + 2*i] = nibble_to_ascii(low_nibble);    // 低4位转换为 ASCII
 183   3          }
 184   2          
 185   2          for (i = 0; i < 16; i++) {
 186   3              UART_sendbyte(card_id[i]);
 187   3          }
 188   2      
 189   2        
 190   2          display_cardnum(FIRST_ROW );
 191   2          status = PcdSelect(g_ucTempbuf); // 选定卡片
 192   2          if (status != MI_OK)
 193   2          {
 194   3            
 195   3              continue;
 196   3          }
 197   2      
 198   2          status = PcdAuthState(PICC_AUTHENT1A, 1, DefaultKey, g_ucTempbuf); // 验证卡片密码
 199   2          if (status != MI_OK)
 200   2          {
 201   3            
 202   3              continue;
 203   3          }
 204   2      
 205   2          // 写卡
 206   2          if (received_data[0] == 'w') { 
 207   3              for (i = 0; i < 10; i++) {
 208   4                  response_array[5 + i] = received_data[1 + i];
 209   4                  write_ok[2 + i] = received_data[1 + i];
 210   4              }
 211   3              status = PcdWrite(2, response_array);  // 写数据
 212   3              if (status != MI_OK) {
 213   4      
 214   4                  continue;
 215   4              }
 216   3              // 返回成功响应
 217   3              for (i = 0; i < 16; i++) {
 218   4                  UART_sendbyte(write_ok[i]);
 219   4              }
 220   3              //显示绑定
 221   3            write_sno(SECOND_ROW );
 222   3              //显示绑定成功
 223   3              write_bang_ding_chen_gong(THIRD_ROW);
 224   3              //清除标志位
 225   3              received_data[0] = 0;
 226   3      
 227   3          // 读取卡片数据
 228   3          } else if (received_data[0] == 'r') {
 229   3              status = PcdRead(2, g_ucTempbuf);
 230   3              if (status != MI_OK) {
 231   4                  continue;
 232   4              }
 233   3              for (i = 0; i < 16; i++) {
 234   4                  UART_sendbyte(g_ucTempbuf[i]);
 235   4              }
 236   3          }
 237   2      
C51 COMPILER V9.59.0.0   MAIN                                                              06/19/2024 00:49:16 PAGE 5   

 238   2          PcdHalt();
 239   2      }
 240   1      }
*** WARNING C280 IN LINE 146 OF MAIN.C: 'temp': unreferenced local variable
 241          
 242          // 系统初始化
 243          void InitializeSystem() {
 244   1                // I/O 端口配置
 245   1          P0M1 = 0x0; P0M2 = 0x0;
 246   1          P1M1 = 0x0; P1M2 = 0x0;
 247   1          P3M1 = 0x0; P3M2 = 0xFF;
 248   1          P0 = 0xFF; P1 = 0xFF; P3 = 0xFF; P2 = 0xFF;
 249   1      
 250   1          // 串口配置
 251   1          SCON = 0x50; // 串行通信模式1，8位数据，允许接收
 252   1      
 253   1          // 定时器配置
 254   1          TMOD = 0x20; // T1为方式2（8位自动重装）
 255   1      
 256   1          // 设置定时器初值
 257   1          TH1 = 0xFA;  // 设置波特率为4800bps
 258   1          TL1 = 0xFA;
 259   1      
 260   1          // 启动定时器1
 261   1          TR1 = 1;    // 启动定时器1
 262   1      
 263   1          // 中断配置
 264   1          ES = 1;      // 允许串行中断
 265   1          EA = 1;      // 开启总中断
 266   1      
 267   1          // 设置标志
 268   1          TI = 1;
 269   1          
 270   1         
 271   1      
 272   1      }
 273          
 274          // UART接收中断服务函数
 275          void UART_R() interrupt 4 {
 276   1          if (RI == 1) {  // 如果接收到数据
 277   2              Char = SBUF;  // 读取接收到的数据到Char变量
 278   2      
 279   2              RI = 0;  // 清除接收标志位
 280   2              if (Char == '#') {  // 检测到结束符
 281   3                  is_read_data = 1;
 282   3      
 283   3                  data_index = 0;  
 284   3              } else {
 285   3                  if (data_index <= MAX_LEN - 1) {  // 防止数组越界
 286   4                      received_data[data_index++] = Char;
 287   4                  }
 288   3              }
 289   2          }
 290   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1203    ----
   CONSTANT SIZE    =      6    ----
   XDATA SIZE       =     87      10
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
C51 COMPILER V9.59.0.0   MAIN                                                              06/19/2024 00:49:16 PAGE 6   

   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  1 WARNING(S),  0 ERROR(S)
