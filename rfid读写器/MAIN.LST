C51 COMPILER V9.59.0.0   MAIN                                                              06/26/2024 23:25:41 PAGE 1   


C51 COMPILER V9.59.0.0, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN ..\..\hex\MAIN.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE MAIN.C LARGE OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND TABS(2) OBJECT(
                    -..\..\hex\MAIN.obj)

line level    source

   1          #include "lpcreg.h"
   2          #include "main.h"
   3          #include "mfrc522.h"
   4          #include "12864.h"
   5          #include <nokia5110.h>
   6          #include <stdio.h>
   7          #include <string.h>
   8          
   9          #define uchar unsigned char // 定义无符号字符类型
  10          #define MAX_LEN 16          // 数据最大长度
  11          #define FIRST_ROW 0
  12          #define SECOND_ROW 2
  13          #define THIRD_ROW 4
  14          
  15          uchar Char;                   // 定义字符变量Char
  16          uchar flag;                   // 定义标志位变量flag
  17          uchar received_data[MAX_LEN]; // 存储接收到的数据
  18          uchar data_index = 0;         // 数据索引
  19          // 前五位cqust   中间10位学生卡号
  20          uchar stu_id[16] = {0x63, 0x71, 0x75, 0x73, 0x74, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x
             -00, 0x23}; // 存储学号格式
  21          
  22          // 第1位d 接10位学号 接4位地址
  23          uchar response_array[16] = {0x64, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
             -0x00, 0x00, 0x23}; // 打卡响应数据帧
  24          
  25          // 前两位 ok  中间十位学生卡号
  26          uchar write_ok[16] = {0x6F, 0x6B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
             -0x00, 0x23}; // 成功响应数组
  27          
  28          // 前六位 cardid 中间8位 标签卡号
  29          uchar card_id[16] = {0x63, 0x61, 0x72, 0x64, 0x69, 0x64, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0
             -x00, 0x23}; // 卡片id响应数组
  30          
  31          // 打卡响应数组
  32          
  33          unsigned char g_ucTempbuf[16];
  34          unsigned char code DefaultKey[6] = {0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF};
  35          
  36          uchar i;
  37          
  38          // 是否读到卡标志 0未读 1读卡
  39          uchar is_card_read = 0;
  40          // 运行模式标志位 0读卡 1写卡
  41          uchar run_mode = 0;
  42          // 是否接收到数据
  43          uchar is_read_data = 0;
  44          
  45          void delay1(unsigned int z)
  46          {
  47   1          unsigned int x, y;
  48   1          for (x = z; x > 0; x--)
  49   1              for (y = 110; y > 0; y--)
  50   1                  ;
C51 COMPILER V9.59.0.0   MAIN                                                              06/26/2024 23:25:41 PAGE 2   

  51   1      }
  52          
  53          // UART发送一个字节函数
  54          void UART_sendbyte(uchar Byte)
  55          {
  56   1          SBUF = Byte;
  57   1          while (TI == 0)
  58   1              ;
  59   1          TI = 0;
  60   1      }
  61          
  62          // 转asc
  63          uchar nibble_to_ascii(uchar nibble)
  64          {
  65   1          if (nibble < 10)
  66   1          {
  67   2              return '0' + nibble;
  68   2          }
  69   1          else
  70   1          {
  71   2              return 'A' + (nibble - 10);
  72   2          }
  73   1      }
  74          
  75          void clear_row(uchar row)
  76          {
  77   1          for (i = 0; i < 15; i++)
  78   1          {
  79   2              LCD_write_shu(i, row, 37);
  80   2          }
  81   1      }
  82          
  83          void display_title(uchar row)
  84          {
  85   1          // cqust考勤系统
  86   1          LCD_write_shu(0, row, 12);
  87   1          LCD_write_shu(1, row, 26);
  88   1          LCD_write_shu(2, row, 30);
  89   1          LCD_write_shu(3, row, 28);
  90   1          LCD_write_shu(4, row, 29);
  91   1      
  92   1          LCD_write_shu(5, row, 37);
  93   1      
  94   1          LCD_write_hanzi(6, row, 0);
  95   1          LCD_write_hanzi(8, row, 1);
  96   1          LCD_write_hanzi(10, row, 2);
  97   1          LCD_write_hanzi(12, row, 3);
  98   1      }
  99          
 100          void display_sno(uchar row)
 101          {
 102   1          // 学号
 103   1          LCD_write_hanzi(0, row, 8);
 104   1          LCD_write_hanzi(2, row, 9);
 105   1          for (i = 0; i < 10; i++)
 106   1          {
 107   2              LCD_write_shu(i+4, row, g_ucTempbuf[5 + i] - '0');
 108   2          }
 109   1      }
 110          
 111          
 112          void display_bang_ding_chen_gong(uchar row)
C51 COMPILER V9.59.0.0   MAIN                                                              06/26/2024 23:25:41 PAGE 3   

 113          {
 114   1          // 绑定成功
 115   1          LCD_write_hanzi(2, row, 10);
 116   1          LCD_write_hanzi(4, row, 11);
 117   1          LCD_write_hanzi(6, row, 6);
 118   1          LCD_write_hanzi(8, row, 7);
 119   1      }
 120          
 121          void display_kao_qing_shi_bai(uchar row)
 122          {
 123   1          // 考勤失败
 124   1          LCD_write_hanzi(3, row, 0);
 125   1          LCD_write_hanzi(5, row, 1);
 126   1          LCD_write_hanzi(7, row, 16);
 127   1          LCD_write_hanzi(9, row, 17);
 128   1      }
 129          
 130          void display_bu_zai_kao_qing_shi_jian(uchar row)
 131          {
 132   1          // 不在考勤时间
 133   1          LCD_write_hanzi(1, row, 12);
 134   1          LCD_write_hanzi(3, row, 13);
 135   1          LCD_write_hanzi(5, row, 0);
 136   1          LCD_write_hanzi(7, row, 1);
 137   1          LCD_write_hanzi(9, row, 14);
 138   1          LCD_write_hanzi(11, row, 15);
 139   1      }
 140          
 141          void display_ben_shi_jian_dun_wu_ke(uchar row)
 142          {
 143   1          // 本时间段无课
 144   1          LCD_write_hanzi(1, row, 18);
 145   1          LCD_write_hanzi(3, row, 14);
 146   1          LCD_write_hanzi(5, row, 15);
 147   1          LCD_write_hanzi(7, row, 19);
 148   1          LCD_write_hanzi(9, row, 20);
 149   1          LCD_write_hanzi(11, row, 21);
 150   1      }
 151          
 152          void display_ben_jie_ke_yi_da_ka(uchar row)
 153          {
 154   1          // 本节课已打卡
 155   1          LCD_write_hanzi(1, row, 18);
 156   1          LCD_write_hanzi(3, row, 22);
 157   1          LCD_write_hanzi(5, row, 21);
 158   1          LCD_write_hanzi(7, row, 23);
 159   1          LCD_write_hanzi(9, row, 4);
 160   1          LCD_write_hanzi(11, row, 5);
 161   1      }
 162          void dispaly_kao_qing_cheng_gong(uchar row, uchar state)
 163          {
 164   1          // 考勤：
 165   1          LCD_write_hanzi(2, row, 0);
 166   1          LCD_write_hanzi(4, row, 1);
 167   1          LCD_write_shu(6, row, 36);
 168   1          if (state == '0')
 169   1          { // 正常
 170   2              LCD_write_hanzi(7, row, 26);
 171   2              LCD_write_hanzi(9, row, 27);
 172   2          }
 173   1          if (state == '1')
 174   1          { // 迟到
C51 COMPILER V9.59.0.0   MAIN                                                              06/26/2024 23:25:41 PAGE 4   

 175   2              LCD_write_hanzi(7, row, 28);
 176   2              LCD_write_hanzi(9, row, 29);
 177   2          }
 178   1          if (state == '2')
 179   1          {
 180   2              // 缺勤
 181   2              LCD_write_hanzi(7, row, 30);
 182   2              LCD_write_hanzi(9, row, 1);
 183   2          }
 184   1      }
 185          
 186          
 187          
 188          void display_cardnum(uchar row)
 189          {
 190   1          unsigned char first, second;
 191   1          // 卡号:
 192   1          LCD_write_hanzi(0, row, 5);
 193   1          LCD_write_hanzi(2, row, 9);
 194   1          LCD_write_shu(4, row, 36);
 195   1          first = (g_ucTempbuf[0] & 0xf0) >> 4;
 196   1          LCD_write_shu(5, row, first); // 写数字
 197   1          second = g_ucTempbuf[0] & 0x0f;
 198   1          LCD_write_shu(6, row, second); // 写数字
 199   1      
 200   1          first = (g_ucTempbuf[1] & 0xf0) >> 4;
 201   1          LCD_write_shu(7, row, first); // 写数字
 202   1          second = g_ucTempbuf[1] & 0x0f;
 203   1          LCD_write_shu(8, row, second); // 写数字
 204   1      
 205   1          first = (g_ucTempbuf[2] & 0xf0) >> 4;
 206   1          LCD_write_shu(9, row, first); // 写数字
 207   1          second = g_ucTempbuf[2] & 0x0f;
 208   1          LCD_write_shu(10, row, second); // 写数字
 209   1      
 210   1          first = (g_ucTempbuf[3] & 0xf0) >> 4;
 211   1          LCD_write_shu(11, row, first); // 写数字
 212   1          second = g_ucTempbuf[3] & 0x0f;
 213   1          LCD_write_shu(12, row, second); // 写数字
 214   1          LCD_write_shu(13, row, 37);
 215   1      }
 216          
 217          // 主函数
 218          void main()
 219          {
 220   1          unsigned char status;
 221   1          unsigned int temp;
 222   1      
 223   1          LCD_init();
 224   1          LCD_clear();
 225   1          display_title(FIRST_ROW);
 226   1          InitializeSystem();
 227   1          PcdReset();
 228   1          PcdAntennaOff();
 229   1          PcdAntennaOn();
 230   1      
 231   1          while (1)
 232   1          {
 233   2      
 234   2              // 写入读卡器所处地址。
 235   2              if (received_data[0] == 's')
 236   2              {
C51 COMPILER V9.59.0.0   MAIN                                                              06/26/2024 23:25:41 PAGE 5   

 237   3      
 238   3                  for (i = 0; i < 4; i++)
 239   3                  {
 240   4                      response_array[i + 11] = received_data[i + 1];
 241   4                  }
 242   3                  for (i = 0; i < 16; i++)
 243   3                  {
 244   4                      UART_sendbyte(write_ok[i]);
 245   4                  }
 246   3      
 247   3                  // 返回成功响应
 248   3              }
 249   2      
 250   2              status = PcdRequest(PICC_REQALL, g_ucTempbuf); // 寻卡
 251   2              if (status != MI_OK)
 252   2              {
 253   3      
 254   3                  display_title(FIRST_ROW);
 255   3                  clear_row(SECOND_ROW);
 256   3                  clear_row(THIRD_ROW);
 257   3                  continue;
 258   3              }
 259   2      
 260   2              status = PcdAnticoll(g_ucTempbuf); // 防冲撞
 261   2              if (status != MI_OK)
 262   2              {
 263   3      
 264   3                  continue;
 265   3              }
 266   2      
 267   2              // 转换卡片发送
 268   2              for (i = 0; i < 4; i++)
 269   2              {
 270   3                  uchar high_nibble = (g_ucTempbuf[i] >> 4) & 0x0F; // 高4位
 271   3                  uchar low_nibble = g_ucTempbuf[i] & 0x0F;         // 低4位
 272   3      
 273   3                  card_id[6 + 2 * i] = nibble_to_ascii(high_nibble); // 高4位转换为 ASCII
 274   3                  card_id[7 + 2 * i] = nibble_to_ascii(low_nibble);  // 低4位转换为 ASCII
 275   3              }
 276   2      
 277   2              for (i = 0; i < 16; i++)
 278   2              {
 279   3                  UART_sendbyte(card_id[i]);
 280   3              }
 281   2      
 282   2              display_cardnum(FIRST_ROW);
 283   2              status = PcdSelect(g_ucTempbuf); // 选定卡片
 284   2              if (status != MI_OK)
 285   2              {
 286   3      
 287   3                  continue;
 288   3              }
 289   2      
 290   2              status = PcdAuthState(PICC_AUTHENT1A, 1, DefaultKey, g_ucTempbuf); // 验证卡片密码
 291   2              if (status != MI_OK)
 292   2              {
 293   3      
 294   3                  continue;
 295   3              }
 296   2      
 297   2              // 写卡
 298   2              if (received_data[0] == 'w')
C51 COMPILER V9.59.0.0   MAIN                                                              06/26/2024 23:25:41 PAGE 6   

 299   2              {
 300   3                  for (i = 0; i < 10; i++)
 301   3                  {
 302   4                      stu_id[5 + i] = received_data[1 + i];
 303   4                      write_ok[2 + i] = received_data[1 + i];
 304   4                  }
 305   3                  status = PcdWrite(2, stu_id); // 写数据
 306   3                  if (status != MI_OK)
 307   3                  {
 308   4      
 309   4                      continue;
 310   4                  }
 311   3                  // 返回成功响应
 312   3                  for (i = 0; i < 16; i++)
 313   3                  {
 314   4                      UART_sendbyte(write_ok[i]);
 315   4                  }
 316   3                  // 显示绑定
 317   3                  display_sno(SECOND_ROW);
 318   3                  // 显示绑定成功
 319   3                  display_bang_ding_chen_gong(THIRD_ROW);
 320   3                  // 清除标志位
 321   3                  received_data[0] = 0;
 322   3      
 323   3                  // 读取卡片绑定的学号
 324   3              }
 325   2              else if (received_data[0] == 'r')
 326   2              {
 327   3                  status = PcdRead(2, g_ucTempbuf);
 328   3                  if (status != MI_OK)
 329   3                  {
 330   4                      continue;
 331   4                  }
 332   3                  for (i = 0; i < 16; i++)
 333   3                  {
 334   4                      UART_sendbyte(g_ucTempbuf[i]);
 335   4                  }
 336   3              }
 337   2              // 打卡模式，返回学号
 338   2              else if (received_data[0] == 'd')
 339   2              {
 340   3                  status = PcdRead(2, g_ucTempbuf);
 341   3                  if (status != MI_OK)
 342   3                  {
 343   4                      continue;
 344   4                  }
 345   3                  for (i = 0; i < 10; i++)
 346   3                  {
 347   4                      response_array[i + 1] = g_ucTempbuf[i + 5];
 348   4                  }
 349   3                  for (i = 0; i < 16; i++)
 350   3                  {
 351   4                      UART_sendbyte(response_array[i]);
 352   4                  }
 353   3                  if (received_data[1] == 'p')
 354   3                  {
 355   4                      display_sno(SECOND_ROW);
 356   4                      if (received_data[2] == '1')
 357   4                          display_kao_qing_shi_bai(THIRD_ROW);
 358   4                      if (received_data[2] == '2')
 359   4                          display_bu_zai_kao_qing_shi_jian(THIRD_ROW);
 360   4                      if (received_data[2] == '3')
C51 COMPILER V9.59.0.0   MAIN                                                              06/26/2024 23:25:41 PAGE 7   

 361   4                          display_ben_shi_jian_dun_wu_ke(THIRD_ROW);
 362   4                      if (received_data[2] == '4')
 363   4                          display_ben_jie_ke_yi_da_ka(THIRD_ROW);
 364   4                      if (received_data[2] == '0')
 365   4                      {
 366   5                          dispaly_kao_qing_cheng_gong(THIRD_ROW, received_data[3]);
 367   5                      }
 368   4                  }
 369   3              }
 370   2              //
 371   2      
 372   2              PcdHalt();
 373   2          }
 374   1      }
*** WARNING C280 IN LINE 221 OF MAIN.C: 'temp': unreferenced local variable
 375          
 376          // 系统初始化
 377          void InitializeSystem()
 378          {
 379   1          // I/O 端口配置
 380   1          P0M1 = 0x0;
 381   1          P0M2 = 0x0;
 382   1          P1M1 = 0x0;
 383   1          P1M2 = 0x0;
 384   1          P3M1 = 0x0;
 385   1          P3M2 = 0xFF;
 386   1          P0 = 0xFF;
 387   1          P1 = 0xFF;
 388   1          P3 = 0xFF;
 389   1          P2 = 0xFF;
 390   1      
 391   1          // 串口配置
 392   1          SCON = 0x50; // 串行通信模式1，8位数据，允许接收
 393   1      
 394   1          // 定时器配置
 395   1          TMOD = 0x20; // T1为方式2（8位自动重装）
 396   1      
 397   1          // 设置定时器初值
 398   1          TH1 = 0xFA; // 设置波特率为4800bps
 399   1          TL1 = 0xFA;
 400   1      
 401   1          // 启动定时器1
 402   1          TR1 = 1; // 启动定时器1
 403   1      
 404   1          // 中断配置
 405   1          ES = 1; // 允许串行中断
 406   1          EA = 1; // 开启总中断
 407   1      
 408   1          // 设置标志
 409   1          TI = 1;
 410   1      }
 411          
 412          // UART接收中断服务函数
 413          void UART_R() interrupt 4
 414          {
 415   1          if (RI == 1)
 416   1          {                // 如果接收到数据
 417   2              Char = SBUF; // 读取接收到的数据到Char变量
 418   2      
 419   2              RI = 0; // 清除接收标志位
 420   2              if (Char == '#')
 421   2              { // 检测到结束符
C51 COMPILER V9.59.0.0   MAIN                                                              06/26/2024 23:25:41 PAGE 8   

 422   3                  is_read_data = 1;
 423   3      
 424   3                  data_index = 0;
 425   3              }
 426   2              else
 427   2              {
 428   3                  if (data_index <= MAX_LEN - 1)
 429   3                  { // 防止数组越界
 430   4                      received_data[data_index++] = Char;
 431   4                  }
 432   3              }
 433   2          }
 434   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1899    ----
   CONSTANT SIZE    =      6    ----
   XDATA SIZE       =    103      16
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  1 WARNING(S),  0 ERROR(S)
